/************************
작성일 : 2025-04-18
동적 배열 변수와 포인터
*************************/

/*
■ 동적이란?
정적의 반대말로, **정해져 있지 않고 바뀔 수 있다**는 뜻
*/

// 정적 선언의 예
int arr[3]; 
// 컴파일 타임에 크기가 3으로 고정되어 결정된다
// 크기 변경이 불가하여 유연성이 부족

/* 프로그래밍을 하다 보면 사용자로부터 어떤 수를 입력받아
그 숫자 만큼의 크기를 갖는 배열 변수를 선언하고 싶을 때가 있는데
그럴 땐 어떻게 해야할까?

이럴 때는 이미 컴파일이 끝나고 프로그램이 실행된 상태에서 
사용자에게 입력값을 받아 배열 변수를 선언한다는 것인데
이렇게 되면 컴퓨터의 입장에서는 사용자가 어떤 수를 입력할 지 
사전에(컴파일 시점에) **알 수 없으므로** 크기를 정해놓지 못하고
상황에 따라 바뀔 수 있는(동적으로) 배열 변수를 선언해야 한다 

이것이 바로 동적 배열 변수의 개념
*/

int n; //C언어와 C++은 선언만하고 초기화 하지 않으면 쓰레기 값이 들어감

std::cin >> n; // 사용자에게 입력 값을 받아 변수 n에 저장

int arr[n]; // 컴파일 오류
//프로그램이 실행된 상태(런타임)에서 사용자에게 입력 받은 값만큼의 크기를 가진 배열을 선언하겠다고 하는 것
//-> 이건 컴파일 시점에는 크기를 얼만큼 메모리게 잡아야 하는지 컴파일러가 알 수 없다
// C++ 표준에서는 컴파일 시점에 배열 크기를 알아야 하기 때문에
// 컴파일러가 얼마나 메모리를 잡아야 하지? 여기서 n은 런타임 중 사용자가 입력한 값이 들어가는 부분이라
// 컴파일 시점헤는 알 수 없다. (이게 되는 컴파일러도 있지만, 표준 C++에서는 불가)

/*
<정리>
C++은 배열의 크기를 컴파일 시점에 알아야한다.
런타임(실행 중)에 정해진다고 하면 컴파일러는 메모리에 얼마를 잡아야 하지? 혼란..
그래서 사용이 불가함.
(일반적으로 배열을 선언할 때는 배열의 크기 값에는 상수가 들어가야함, 변수(변하는 수) 불가)
(상수 : 한 번 정해지면 고정되어 (프로그램의 시작과 종료까지)절대 변하지 않는 값
예) 상수 리터럴(숫자 10,20) 또는 const로 선언한 상수)

배열의 크기 : 컴파일 시점에 고정되어야 하기 때문에 상수만 가능, 런타인에 변하는 값이나 변수 불가
*/

// 근데 난 런타임(프로그램 실행 중)에 값을 받아서 배열을 선언하고 싶은데?
// 그럼 어떻게 해야 돼?

//=> new를 사용해서 동적 배열로 만든다!
// 동적 메모리 할당(new 연산자)
/*
new 연산자는 동적 메모리 할당을 위해 사용된다
동적 배열을 만들 면 배열의 크기를 런타임에 결정 할 수 있다

*/

/* ■ 포인터
* 특정 변수의 주소값을 가지고 있는 변수(주소를 저장하는 변수)
* C언어 계열의 언어들이 가지고 있는 특징
* 여기서 말하는 주소값이란? 특정 변수의 값이 컴퓨터 메모리 어디에 저장되어 있는지에 대한 주소를 말함
* 포인터의 장점 : 세밀한 메모리 관리가 가능함
* 단점 : 번거롭다(메모리 누수 조심)
 
 선언시 *를 붙여서 선언함

  *의 역할 : 
  1) 포인터 선언(에서의 *)
	"포인터 변수"임을 알리는 문법
	int* ptr;은 int값을 가리키는 포인터라는 뜻(int *ptr;과 같은 의미, 요즘엔 데이터타입 뒤에 *을 붙임)
  포인터 ptr은 int값이 저장된 주소가 들어감, 이 변수가 포인터라는 것을 알려줌
  
  2) 역참조(포인터가 가리키는 주소의 **실제 값**에 접근함)
  * = 역참조 연산자 ← 포인터가 가리키는 메모리 주소의 실제 값을 간접적으로 접근함
    포인터가 가지고 있는 주소를 "따라가서"
	그 주소에 **실제로 저장된 값**에 접근하는 연산자
	int num = 10;
	int* ptr = &num;

    간단 비유
	num은 내 방에 있는 책
	ptr은 내 방 주소가 적힌 쪽지
	*ptr은 그 주소를 따라가서 방에 들어가 책을 꺼내는 행위

	*ptr은 ptr이 가지고 있는 주소를 따라가서 메모리 위치에 접근
	ptr이 직접 값을 가지고 있는 건 아니고, 값이 저장된 곳의 주소만 알고 있음.
	*ptr은 그 주소를 "간접적으로 참조(접근)" 해서 값을 읽는 것!
 */

/* ■ 1차원 동적 배열 선언 */
int n;

std::cin >> n;

int* arr = new int[n];

/*
new int[n]의 의미
int 크기의 공간을 n개 연속으로 힙에 요청
"정수 int를 저장할 수 있는 공간을 n개 힙에 만들어줘!"
그리고 그 공간의 시작 위치의 주소를 포인터arr에 저장해줘!
new 연산자 = "힙에 동적 메모리 할당 요청하고, 그 시작 주소를 반환하는 연산자"

동적 배열 생성하면서 포인터 변수에 담는 이유
new int[n];는 동적으로 생성된 배열 공간(연속적으로 생성된 공간)의 시작위치의 주소를 반환하는건데
int arr는 주소 저장이 불가한 변수 선언이다..타입이 맞지 않음
주소를 저장하려면 포인터 사용!
그래서 동적으로 배열을 선언할 땐 포인터와 new 연산자를 이용해서 코드를 작성한다
*/

/*
<그림으로 비유>

new int[3]; // 요청하면 힙에서 공간을 이렇게 줌 

[ 쓰레기값 ][ 쓰레기값 ][ 쓰레기값 ]
    arr[0]     arr[1]     arr[2]

  new int[3];로 int타입 3칸을 저장할 수 있는 연속적인 공간을 동적으로(런타임에) 메모리 힙 공간에 배열을 만든 것이고
  int* arr = new int[3];는 동적으로 할당된 공간의 시작 주소(arr[0]의 주소)를 포인터 변수 arr에 저장시킨 것

  "힙 메모리에 int 3칸짜리 연속 공간을 요청해서 만듦"
  "new int[3]으로 만든 공간의 시작 주소(arr[0])를 반환 -> 포인터 arr에 저장"
  "arr는 포인터니까 이 주소를 저장 가능"
  포인터 arr에 저장된 주소는 arr[0]의 주소

<배열 인덱스 접근>
배열의 인덱스를 사용하는 arr[0]은 사실 *(arr + 0)와 동일
그래서 arr[0]도 값을 직접 읽어오는 방법
배열의 이름 자체가 첫 번째 요소의 주소를 가리키는 포인터 역할을 하니까

arr[0]   == *(arr + 0)  == *arr  // 첫 번째 요소의 값
arr[1]   == *(arr + 1)   // 두 번째 요소의 값

arr은 arr[0]의 주소를 담고 있는 포인터
arr[0]은 *arr(담고있는 주소의 실제 값을 읽어옴)과 같음
*(arr + 1)과 arr[1]이 같은 이유는
arr + 1은 
arr[0]의 주소 + 1인데
포인터 연산은 계산되는 단위가 다르다
arr + 1은 arr에 저장되어 있는 주소에 그냥 +1을 하는 것이 아니라,
포인터 선언 시에 정의한 타입의 크기 만큼 건너뛰어서 다음 요소의 주소로 가는 연산임
int* arr;이었으면 arr + 1하면 int크기만큼(타입 크기(sizeof)만큼) 더해지는 연산
그래서 arr + 1은 arr[1]의 주소이고
*(arr + 1)는 arr[1]의 실제 값
즉 *(arr + 1)과 arr[1]은 동일하다
(*는 포인터가 가리키는 주소를 따라가서 실제 값을 꺼내는(읽거나 쓰는) 연산자, 
*arr은 그 주소에 저장된 실제 값을 읽어옴)

혼동할 수 있는 점 (핵심 포인트!)
포인터 자체는 주소를 담고 있는 변수이고, 
그 주소에 있는 실제 값에 접근하려면 *을 사용해야 한다

하지만, 배열의 인덱스 접근 (arr[0])은 
이미 값을 가져오는 형태이기 때문에 *을 쓰지 않아도 값에 바로 접근할 수 있다.

배열의 이름 arr은 첫 번째 요소의 주소를 가리키는 포인터
arr[0]은 그 주소에 저장된 실제 값을 가져온다
arr[0] == *arr
주소에 있는 값을 바로 읽는 방식

포인터가 가리키는 주소에서 실제 값에 접근하려면 *을 사용한다



int* arr = new int[5];

여기서 new int[5]는 다음을 수행:

1. "int형 5개를 저장할 수 있는 연속된 공간을 힙에 요청해!"
2. 운영체제가 그만한 연속된 메모리 공간을 힙 영역에 할당
3. 그리고 그 첫 번째 요소의 주소를 반환
4. 그 주소를 arr 포인터에 저장

<new 연산자의 특징 요약>
할당 위치 : 힙(Heap) 메모리 영역
크기 결정 시점 : 런타임 (실행 중)
반환값 : 할당된 메모리의 시작 주소 (포인터에 저장함)
타입 : 할당된 타입의 포인터 (int*, double* 등)
해제 방법 : delete 또는 delete[] 사용

int* ptr = new int;     // int 하나를 위한 공간
int* arr = new int[10]; // int 10개짜리 배열 공간

//→ 둘 다 힙에 메모리를 할당하고
//→ 시작 주소를 반환해서 포인터에 저장하는 구조
*/

/*
new : 런타임(프로그램 실행 중)에 동적으로 메모리를 할당해 주는 연산자
코드가 실행되는 도중에 원하는 크기만큼 메모리를 힙 영역에 요청해서 할당할 수 있음
C++에서는 new로 메모리에 할당 했으면 delete로 메모리 해제를 해야한다, 안하면 메모리 누수 발생
new → delete / new[] → delete[] 꼭 세트로 기억!
(메모리 누수란? 더 이상 쓸 필요가 없는 메모리를 할당한 채로, 해제하지 않아서 메모리를 영원히 잡아먹는 현상)
(비유하자면 방(메모리)을 빌렸는데 체크아웃(해제)을 하지 않고 나가서 손님은 안에 없는데, 
방은 계속 사용 중으로 남아 있는 것, 그래서 다른 사람은 그 방을 쓰지 못함.. 그런 방들이 쌓여서 꽉차면 운영이 마비됨) */

int* p = new int[100]; // 크기 100칸짜리 int 배열 할당
//... 여기서 p를 더 이상 안 씀

// delete[] p; ← 안 했음!!
// 이제 이 100칸은 영원히 힙에 남아버림 → 메모리 누수

/*
결론
메모리 누수 = 빌린 메모리를 안 돌려줌
C++에선 개발자가 책임지고 free 해줘야 함
안 하면? → 메모리 점유만 늘어나다 결국 터짐
*/

/*
비유 : 
	int arr[5]: 집 짓기 전에 미리 땅 다 파놓고 방 5개 만들기 (컴파일 시 결정, 정적 배열 선언)
	new int[n]: 살다가 사람 수 많아지면 바로 현장에 가서 방 n개 짓기 (실행 중 결정, 동적 배열 선언)
*/

/* 2차원 동적 배열 변수 선언 */
int** arr = new int*[row]; // [행] 수 만큼 "int 포인터" 공간 할당하고, 
// 그 공간의 시작 주소(arr[0]의 주소)를 반환해서 arr에 저장
// new 연산자는 메모리 힙공간에 동적으로 할당을 요청하고, 그 공간의 시작 주소(맨 처음 주소)를 반환함

for (int i = 0; i < row; ++i) {
	arr[i] = new int[col]; // 각 행마다 [열] 배열 따로 생성
}

/*
new int*[row];가 무엇인지?
int 포인터를 row개 생성해서 "연속된 메모리 공간"에 저장한 것
즉, **"포인터 배열"**을 동적으로 만든 거예요!(그냥 배열이 아니고 포인터 배열을 만듬)
우리가 2차원 배열을 동적 할당할 때는, 행마다 열을 따로따로 만들어야 한다
먼저 행만큼의 포인터들이 들어갈 공간이 필요
여기서 각 arr[i]는 int* 타입 (열이 들어감)

new int[row];
정수(int) 값을 row개 저장하는 공간 만들기

new int*[row];
정수 포인터(int*)를 row개 저장하는 공간 만들기
즉, 2차원 배열의 '행들'을 가리키기 위한 공간
"행을 담기 위한 포인터 배열"
각 행에는 new int[col];로 만든 열 배열을 넣는 구조

int** arr의 뜻(int **arr과 같음)
int** arr은 이중 포인터
int*를 가리키는 포인터
int는 정수 하나
int*은 정수 하나의 주소를 저장하는 포인터
int**은 정수 포인터(int*)의 주소를 저장하는 포인터
배열의 배열 -> 2차원 배열을 가리킴

왜 열은 반복문을 돌려서 선언할까?
2단계로 동적할당을 하기 때문

		   열0       열1        열2       열3
	   ┌────┬────┬────┬────┐
행0 → │        │        │        │        │   ← arr[0]
	   └────┴────┴────┴────┘
	   ┌────┬────┬────┬────┐
행1 → │        │        │        │        │   ← arr[1]
	   └────┴────┴────┴────┘
	   ┌────┬────┬────┬────┐
행2 → │        │        │        │        │   ← arr[2]
	   └────┴────┴────┴────┘


*/

/*
2차원 동적 배열을 선언하는 과정
행부분, 열부분 각각 따로 선언한다

먼저 행 부분은
new int*[row];로 row(행)의 수만큼의 포인터 배열을 동적으로 할당하고 
포인터 배열(주소를 저장하는 배열)의 시작 주소를 반환함
그래서 int** 포인터 주소(int*)를 저장하는 포인터에 담는 것
이 포인터 배열은 각 행에 대한 주소를 저장하는 용도로 사용

열부분 :
각 행에 대해 new int[col];로 int크기의 연속적인 공간을 col(열)의 수만큼 
동적으로 할당함

new int*[row];는 행을 위한 포인터 배열을 생성하고
각 포인터는 각 행에 해당하는 열을 가리킬 수 있게 된다

1차원 배열의 arr[i]와 2차원 배열의 arr[i]은 다르다
1차원 배열의 arr[i]는 인덱스i번째 요소 값을 의미하고
2차원 배열에서의 arr[i]는 인덱스 i번째 행 전체를 의미함 

동적 배열에서 arr[i]는?
여기서도 arr[i]는 1차원 배열을 가리키는 포인터
 arr[i]는 실제로 int* 타입이고, int[col]이라는 배열을 가리키고 있음

 먼저 행 수만큼 주소 저장 공간을 만들고 (포인터 배열)
 각 행에 열 배열을 붙인다 = 그 포인터 배열 각각에 열 배열을 연결
 arr은 "포인터의 배열"이고,
 그 각 포인터들이 new int[col]을 통해 열 배열을 가리키도록 연결하는 것 = 열을 행에 붙인다

 "각 행에 해당하는 포인터 공간을 먼저 만들고,
그 각각의 포인터 공간에 열 배열을 가리키는 주소를 넣는다!"

int** arr = new int*[row];
→ 이건 row개짜리 포인터 배열을 만든다는 뜻이에요.
즉, "행만큼의 주소 저장 공간(포인터)을 만든다"는 거예요.

arr
 ↓
[ptr][ptr][ptr]  ← row 개수만큼의 포인터 공간

arr[i] = new int[col];
→ 이건 열(col)만큼의 정수 배열을 동적으로 만들어서
→ 그 시작 주소를 arr[i]에 저장하는 거예요.
 열 배열을 만들어서 행 포인터에 연결하는 거예요.

 최종적으로는 아래처럼 메모리가 구성된다
 arr
 ↓
[ 0x100 ] → [0][1][2][3]
[ 0x200 ] → [0][1][2][3]
[ 0x300 ] → [0][1][2][3]

여기서 [0x100], [0x200] 등은 열 배열의 시작 주소,
즉 열 배열을 가리키는 포인터가 저장

각 행에 해당하는 포인터 공간을 먼저 만들고,
그 각각의 포인터 공간에 열 배열을 가리키는 주소를 넣는다!"

2차원 동적 배열에서 arr[i][j]의 의미는?
 i번째 포인터가 가리키는 배열의 j번째 요소

 각 행마다 메모리를 따로 할당해야 하는 이유?
 2차원 동적 배열은 한 덩어리로 메모리가 잡히지 않는다. arr[i]마다 별도로 열 공간을 잡아야한다
*/